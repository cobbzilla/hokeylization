هوکیلیزاسیون
 ==============
 چرا نمی توانم کل برنامه یا سایت خود را از طریق Google Translate اجرا کنم و ترجمه اولیه را به زبان دیگری دریافت کنم؟

 ***حالا می توانید!***

 نام `hokeylization` یک portmanteau به معنای "محلی سازی هوکی" است.

 این تا حدودی جالب است زیرا بسیار ساده است: رشته هایی را به Google Translate ارسال می کند

 و ساده و در عین حال بسیار قدرتمند است. دارای پشتیبانی ویژه برای اسناد HTML،
 الگوهای [HandlebarsJS](https://handlebarsjs.com/)،
 و فایل های [Markdown](https://daringfireball.net/projects/markdown).

 می توانید ترجمه کنید:
 * یک شی جاوا اسکریپت حاوی پیام
 * هر تعداد فایل یا دایرکتوری، همیشه دایرکتوری ها را به صورت بازگشتی طی می کنند

 # این را به زبان دیگری بخوانید
 این سند README.md با استفاده از خود ابزار hokeylization به ترجمه شده است
 **[هر زبانی که توسط Google Translate پشتیبانی می‌شود](https://cloud.google.com/translate/docs/languages)!**

 من مطمئنم که کامل نیست، اما امیدوارم از هیچی بهتر باشد!

 [🇸🇦 عربی](../ar/README.md)
 [🇧🇩 بنگالی](../bn/README.md)
 [🇩🇪 آلمانی](../de/README.md)
 [🇺🇸 انگلیسی](../en/README.md)
 [🇪🇸 اسپانیایی](../es/README.md)
 [🇫🇷 فرانسوی](../fr/README.md)
 [🇹🇩 هاوسا](../ha/README.md)
 [🇮🇳 هندی](../hi/README.md)
 [🇮🇩 اندونزیایی](../id/README.md)
 [🇮🇹 ایتالیایی](../it/README.md)
 [🇯🇵 ژاپنی](../ja/README.md)
 [🇰🇷 کره ای](../ko/README.md)
 [🇮🇳 Maranthi](../mr/README.md)
 [🇵🇱 لهستانی](../pl/README.md)
 [🇧🇷 پرتغالی](../pt/README.md)
 [🇷🇺 روسی](../ru/README.md)
 [🇰🇪 سواحیلی](../sw/README.md)
 [🇵🇭 تاگالوگ](../tl/README.md)
 [🇹🇷 ترکی](../tr/README.md)
 [🇵🇰 اردو](../ur/README.md)
 [🇻🇳 ویتنامی](../vi/README.md)
 [🇨🇳 چینی](../zh/README.md)


 **[📚 ... همه زبان ها ...](../README.md)**
 ----

 ### آیا این ترجمه README مشکلی دارد؟
 این ترجمه خاص از [README] اصلی (https://github.com/cobbzilla/yuebing/blob/master/README.md)
 ممکن است ناقص باشد -- *اصلاحات بسیار خوش آمدید!* لطفاً یک [درخواست کشش در GitHub](https://github.com/cobbzilla/yuebing/pulls) ارسال کنید.
 یا اگر از انجام آن راحت نیستید، [مشکلی را باز کنید](https://github.com/cobbzilla/yuebing/issues)

 هنگامی که یک مشکل جدید GitHub در مورد ترجمه ایجاد می کنید، لطفاً این کار را انجام دهید:
 * شامل URL صفحه (کپی/پیست از نوار آدرس مرورگر)
 * متن دقیق اشتباه را شامل شود (کپی/پیست از مرورگر)
 * لطفاً توضیح دهید که چه چیزی اشتباه است -- آیا ترجمه صحیح نیست؟ آیا قالب بندی به نوعی خراب است؟
 * لطفاً پیشنهادی برای ترجمه بهتر یا نحوه قالب بندی صحیح متن ارائه دهید
 * **متشکرم!**

 # فهرست
 * [منبع](#منبع)
 * [Support and Funding](#Support-and-Funding)
 * [نصب](#نصب)
 * [تنظیم](#تنظیم)
 * [ترجمه فایل منبع رشته جاوا اسکریپت](#Translating-a-JavaScript-string-resource-file)
 * [ترجمه فهرستی از فایل های متنی](#Translating-a-directory-of-text-files)
 * [گزینه‌های دیگر](#گزینه‌های دیگر)
 * [دستورات دسته ای JSON](#JSON-batch-commands)

 ## منبع
 * [hokeylization در GitHub](https://github.com/cobbzilla/hokeylization)
 * [hokeylization در npm](https://www.npmjs.com/package/hokeylization)

 ## پشتیبانی و تامین مالی
 من سعی می کنم یک توسعه دهنده نرم افزار متن باز حرفه ای باشم. من در حال کار بوده ام
 در صنعت نرم افزار سال هاست که شرکت های موفقی راه اندازی کرده ام و آنها را به شرکت های دولتی فروخته ام.
 اخیراً کارم را از دست داده‌ام و واقعاً کار دیگری ندارم

 بنابراین من سعی می کنم نرم افزار مفید بنویسم و ببینم آیا کار می کند یا خیر

 حتی از کوچکترین [کمک مالی ماهانه از طریق Patreon] صمیمانه قدردانی می کنم (https://www.patreon.com/cobbzilla)

 ## نصب و راه اندازی
 برای استفاده از ابزار خط فرمان، با استفاده از `npm` » یا `yarn` کنید:

    npm install -g hokeylization
    yarn global add hokeylization

 برای استفاده به عنوان کتابخانه، نسخه `lite` را نصب کنید که بسیار کوچکتر است:

    npm install -g hokeylization-lite
    yarn global add hokeylization-lite

 سپس به کمک دستور `hokey` نگاه کنید:

    hokey --help
    hokey -h

 آیا می خواهید خروجی را به زبان خود یا زبان دیگری ببینید؟

 `hokey` سعی می کند زبان را به طور خودکار از متغیرهای محیط پوسته شما تشخیص دهد

 می‌توانید با تنظیم متغیر محیطی `LC_ALL` یک زبان را مجبور کنید:

    LC_ALL=it hokey --help

 توجه داشته باشید که اگر `hokeylization-lite` را نصب کرده‌اید، راهنمای فرمان فقط به زبان انگلیسی در دسترس است

 ## برپایی
 متغیر محیطی `GOOGLE_TRANSLATE_PROJECT_ID` را برای شناسایی پروژه Google Translate خود تنظیم کنید

 متغیر محیطی `GOOGLE_APPLICATION_CREDENTIALS` را روی اعتبارنامه‌های JSON که دانلود کرده‌اید تنظیم کنید
 پس از فهمیدن اینکه چگونه احراز هویت در ابر گوگل کار می کند (می تواند سرگرم کننده باشد)

 اگر از کد منبع اجرا می‌کنید، می‌توانید آن‌ها را نیز در فایل `.env` در منبع قرار دهید
 دایرکتوری آنها در زمان اجرا از طریق [dotenv] بارگیری می شوند (https://www.npmjs.com/package/dotenv)

 ## ترجمه یک فایل منبع رشته جاوا اسکریپت
 جدول رشته شما **باید** در یک فایل جاوا اسکریپت به یکی از این دو شکل باشد:

 صادرات ES6:

    export default {
      string_key: "some value",
      another_key: "another value",
      ... more keys ...
    }

 صادرات CommonJS

    module.exports = {
      string_key: "some value",
      another_key: "another value",
      ... more keys ...
    }

 اگر این فایل `myfile.en.js` نام داشت، می‌توانید آن را به اسپانیایی و آلمانی ترجمه کنید:

    hokey -l es,de -o myfile.LANG.js myfile.en.js

 `LANG` در بالا خاص است -- یک کلمه رزرو شده در این ابزار است!

 `LANG` با کد زبان فایل های خروجی جایگزین می شود

 بنابراین دستور بالا فایل ها را ایجاد می کند:

    myfile.es.js
    myfile.de.js

 گزینه «-l» / `--languages` `-l` از کدهای زبان ISO است که با کاما از هم جدا شده اند.
 [پشتیبانی شده توسط Google Translate](https://cloud.google.com/translate/docs/languages)

 اگر فایل خروجی از قبل وجود داشته باشد، بررسی می شود تا مشخص شود کدام کلیدها از قبل وجود دارند.
 کلیدهای موجود ترجمه نمی شوند. ترجمه‌های کلیدهای گمشده ایجاد و اضافه می‌شوند
 تا انتهای شیء JS. کل فایل همیشه بازنویسی می شود.

 برای اجباری کردن ترجمه مجدد همه کلیدها، از گزینه `-f` » / `--force` کنید

 ## ترجمه فهرستی از فایل های متنی
 همچنین می توانید فهرستی از فایل ها را ترجمه کنید. hokeylization به صورت بازگشتی از هر بازدید می کند
 فایل را در دایرکتوری قرار دهید و محتویات آن را از طریق Google Translate اجرا کنید و خروجی را ذخیره کنید
 به یک فایل با نام یکسان در یک درخت دایرکتوری جداگانه

 هنگامی که هدف ترجمه شما یک فهرست باشد، این حالت فعال می شود

 گزینه `-o` / `--outfile` دایرکتوری خروجی را مشخص می کند

 **هشدار بزرگ**: هنگام ترجمه دایرکتوری ها، **دایرکتوری خروجی را مشخص نکنید**
 که در دایرکتوری ورودی شما قرار دارد! اگر این کار را انجام دهید، انجام خواهید داد:
 * ایجاد بازگشت بی نهایت
 * صورت حساب گوگل خود را اجرا کنید
 * دیسک خود را پر کنید
 * کمتر تفریح کنید

 در اینجا نمونه ای از کارهایی است که *نباید انجام داد*:

    hokey -l es -o templates/es templates # <--- DON'T DO THIS!

 وقتی این اجرا می‌شود، فایل‌های ترجمه‌شده در `templates/es` نوشته می‌شوند و بنابراین جدید می‌شوند
 فایل‌های منبع برای ترجمه، از آنجایی که آنها تحت `templates/` هستند -- این روند ادامه می‌یابد
 برای همیشه، این کار را نکن!

 #### استفاده صحیح
 خوب، فرض کنید چند الگوی ایمیل در یک فهرست دارید:

    templates/email/en/welcome.txt
    templates/email/en/welcome.html
    templates/email/en/verify-account.txt
    templates/email/en/verify-account.html
    templates/email/en/reset-password.txt
    templates/email/en/reset-password.html

 برای ترجمه همه اینها به اسپانیایی و آلمانی، اجرا کنید:

    hokey -l es,de -o templates/email/LANG templates/email/en

 در بالا، `LANG` یک کلمه رزرو شده است و با کد زبان ISO جایگزین می شود

 چه اتفاقی می‌افتد وقتی موارد بالا اجرا شود:
 * دایرکتوری `templates/email/es` » و `templates/email/de` ایجاد خواهند شد (اگر وجود نداشته باشند)
 * هر فایل در `templates/email/en` " به اسپانیایی و آلمانی ترجمه خواهد شد
 * فایل‌های خروجی موجود دوباره تولید نمی‌شوند مگر اینکه از `-f` » / `--force` استفاده کنید
 * در نهایت با ساختار دایرکتوری و فایل‌های یکسانی در `es` » و `de` مانند `en`

 ## گزینه های دیگر

 ### اجرا خشک
 برای نمایش آنچه انجام می شود، `-n` » / `--dry-run` را پاس کنید، اما در واقع هیچ تماس API یا نوشتن فایلی انجام ندهید.

 ### زور
 `-f` / `--force` را پاس کنید تا همیشه ترجمه‌ها را بازسازی کنید، حتی اگر از قبل وجود داشته باشند

 ### همخوانی داشتن
 `-m` / `--match` را برای محدود کردن فایل‌های پردازش شده هنگام اجرا در حالت دایرکتوری عبور دهید

 ممکن است همیشه نخواهید *هر* فایل موجود در فهرست منبع خود را به فهرست هدف خود ترجمه کنید

 مقدار گزینه `-m` / `--match` یک regex است (مراقب قوانین نقل قول پوسته باشید!) که مشخص می کند
 کدام فایل ها باید ترجمه شوند

 در صورت شک، می‌توانید این گزینه را با `-n` / `--dry-run` کنید تا ببینید کدام فایل‌ها ترجمه می‌شوند.

 ### مستثنی می شود
 گاهی اوقات `-m` شما با تعداد زیادی فایل مطابقت دارد. برای حذف صریح از گزینه «-e» / `--excludes` `-e` » استفاده کنید
 فایل هایی که در غیر این صورت مطابقت داشتند

 شما می توانید چندین regexe را لیست کنید که با فاصله از هم جدا شده اند

 یک استفاده متداول این خواهد بود: `--excludes node_modules dist \.git build tmp`

 ### فرمان
 رشته‌هایی که باید ترجمه شوند ممکن است دارای الگوهای `{{ handlebars }}` باشند، با دو یا سه پرانتز فرفری

 احتمالاً *نمی‌خواهید* مطالب داخل آن الگوها ترجمه شوند

 پرچم «-H» / `--handlebars` `-H` پاس کنید، و هر چیزی در `{{ ... }}` ترجمه نخواهد شد

 ### مارک داون
 Markdown نه متنی است و نه html، بنابراین Google Translate با آن مشکلاتی دارد

 پرچم «-M» / `--markdown` `-M` خاصی را برای فایل‌های نشانه‌گذاری فعال می‌کند

 با فایل های علامت گذاری، اگر از پرچم `-M` استفاده نمی کنید، احتمالاً این مشکلات را پیدا خواهید کرد:
 * لینک های خراب در ترجمه، یک کاراکتر فاصله پس از پایان توضیحات پیوند علامت گذاری (با `]` ) ظاهر می شود اما
 قبل از شروع پیوند هدف آن (با `(` ). این باعث می شود علامت گذاری به اشتباه ارائه شود و پیوند
 هنگام مشاهده سند خراب است.
 * بلوک های کد ترجمه می شوند. گوگل ترنسلیت نمی داند که علامت گذاری کد را در نظر می گیرد و چه چیزی را نمی داند
 * فاصله نادرست برای بلوک های کد فرورفته. حفظ فاصله در ترجمه دشوار است
 * وقتی تقریباً همیشه بخواهید که مقادیر تحت اللفظی باشند، چیزهای داخل `backticks` ترجمه می‌شوند

 وقتی پرچم `-M` -M» / `--markdown` فعال است:
 * الگوی `](` متراکم می شود `](` بنابراین پیوندهای علامت گذاری شکسته رفع می شوند
 * یک بسته بندی "بدون ترجمه" در اطراف بلوک های کد فرورفته قرار داده می شود و از تورفتگی مناسب محافظت می کند و از ترجمه نشدن آنها اطمینان می یابد.
 * یک بسته بندی "بدون ترجمه" در اطراف متن در `backticks` قرار می گیرد تا اطمینان حاصل شود که آنها ترجمه نمی شوند.

 ### فرآیند به عنوان
 به طور معمول همه چیز به صورت متن ساده پردازش می شود

 اگر محتوای شما HTML باشد، مخدوش می‌شود مگر اینکه گزینه `-p html` » / `--process-as html` را پاس کنید.

 ### فیلتر
 برای افراد ماجراجو: هنگام پردازش فایل‌ها در یک فهرست، می‌توانید گزینه «-F» / `--filter` `-F` پاس کنید.
 برای فیلتر کردن خروجی قبل از اینکه در سیستم فایل نوشته شود

 مقدار این گزینه باید مسیری به یک فایل JS باشد که تابعی به نام `filter`

 تابع `filter` فیلتر» باید `async` زیرا `await` انتظار» بر روی آن فراخوانی می‌شود

 قبل از اینکه فایل‌ها روی دیسک نوشته شوند، کل محتوای فایل به‌عنوان یک رشته به تابع `filter` می‌شود

 مقدار بازگشتی از تابع `filter` همان چیزی است که واقعاً در ذخیره‌سازی نوشته می‌شود

 بنابراین، شما کنترل کاملی بر آنچه در نهایت نوشته خواهد شد دارید

 ### کمک
 برای نشان دادن کمک از `-h` » / `--help` استفاده کنید

 ## دستورات دسته ای JSON
 با گزینه `-j` » / `--json` ، می توانید چندین دستور هماهنگ `hokey` را اجرا کنید

 طبق قرارداد، این فایل `hokey.json` نامیده می‌شود، اما می‌توانید آن را هر چه می‌خواهید نامگذاری کنید

 اگر دایرکتوری را به عنوان گزینه `-j` کنید، `hokey` به دنبال `hokey.json` در آن دایرکتوری می‌گردد.

 فایل JSON باید حاوی یک شی باشد. در داخل آن شی، نام ویژگی های آن مشابه است
 گزینه های خط فرمان، به علاوه یک ویژگی اضافی به نام `hokey`

 ویژگی `hokey` آرایه ای از دستورات برای اجرا است. خواص اعلام شده در این دستورات خواهد بود
 هر گونه اعلان تکراری در شی بیرونی را لغو کنید.

 در هر شی در آرایه `hokey` ، باید `name` و فایل های ورودی و خروجی را مشخص کنید.

 در اینجا نمونه ای از `hokey.json`

    {
        "inputLanguage": "en",
        "languages": "es,fr,ja", # can also be an array of strings
        "force": false,
        "match": null,
        "processAs": null,
        "excludes": ["exclude-1", "exclude-2"],
        "handlebars": false,
        "markdown": false,
        "regular": false,
        "dryRun": false,
        "filter": "theFilter.js",
        "hokey": [
          {
            "name": "locale names",
            "infile": "messages/locales_en.js",
            "outfile": "messages/locales_LANG.js",
            "handlebars": true
          },
          {
            "name": "CLI messages",
            "infile": "messages/en_messages.js",
            "outfile": "messages/LANG_messages.js",
            "handlebars": true
          },
          {
            "name": "README",
            "infile": "README.md",
            "outfile": "lang/LANG/",
            "excludes": ["lang/", "node_modules/", "\\.git/", "tmp/"],
            "filter": "util/filterReadme.js",
            "markdown": true,
            "index": "lang/README.md"
          }
        ]
    }

 ### چندین فایل ورودی
 مانند این مثال، آرایه ای از مسیرهای فایل را به عنوان `infiles` به جای یک مسیر `infile` کنید:

    {
      ... [
        {
          "name": "my docs",
          "infiles": ["README.md", "INSTALL.md", "TUTORIAL.md"],
          "outfile": "docs/LANG/",
          "markdown": true
      ]
    }

 ### شاخص ها
 هنگام ترجمه به بسیاری از زبان‌ها، `hokey` می‌تواند یک فایل فهرستی ایجاد کند که تمام ترجمه‌های انجام شده را فهرست می‌کند
 و به آنها لینک می دهد

 *هنگام تولید نمایه ها، می توانید تنها یک منبع ورودی داشته باشید*

 گزینه `-I` » / `--index` را پاس کنید، مقدار جایی است که فایل فهرست تولید می شود که می تواند یک فایل باشد.
 یا یک دایرکتوری اگر یک دایرکتوری است، از یک نام فایل پیش‌فرض بر اساس الگو استفاده می‌شود (به زیر مراجعه کنید)

 از `-A` » / `--index-template` برای تعیین نحوه قالب بندی خروجی فهرست استفاده کنید. شما می توانید 'html' را مشخص کنید،
 'markdown'، 'text'، یا مسیر فایل به الگوی [HandlebarsJS](https://handlebarsjs.com/) خودتان

 اگر الگوی خود را مشخص کنید، باید یک فایل (نه دایرکتوری) برای `-I` » / `--index` نیز مشخص کنید.
 گزینه

 ## با ترجمه زبان ها خوش بگذرانید!

</pre>
